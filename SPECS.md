# NoirJS + Barretenberg Benchmarking CLI - Especificaciones T√©cnicas

## üéØ Objetivo
Crear un CLI completo para medir y optimizar el rendimiento computacional y de memoria en el pipeline de generaci√≥n de pruebas ZK usando NoirJS y bb.js (Barretenberg).

---

## üìñ Glosario y Conceptos Clave

### Terminolog√≠a ZK
- **ACIR (Abstract Circuit Intermediate Representation):** Bytecode intermedio que representa las constraints del circuito Noir
- **ACVM (Abstract Circuit Virtual Machine):** VM que ejecuta ACIR y produce el witness
- **Witness:** Vector de valores de wires que satisfacen las constraints del circuito
- **SRS (Structured Reference String):** Par√°metros comunes (puntos en curva, FFT) para compromisos polinomiales
- **Backend:** Esquema de prueba implementado (UltraPlonk/UltraHonk en Barretenberg)
- **Proof:** Artefacto criptogr√°fico final verificable

### Pipeline de Generaci√≥n de Pruebas
```
1. ACIR Decode: base64 ‚Üí bytes ‚Üí gunzip ‚Üí ACIR object
2. ACVM Execute: ACIR + inputs ‚Üí witness generation  
3. Backend Init: cargar SRS + configurar proving system
4. Proof Generation: witness ‚Üí generate proof (UltraPlonk/UltraHonk)
5. Verification: proof + public inputs ‚Üí verify
```

---

## üèóÔ∏è Arquitectura del Sistema

### Estructura de Directorios
```
noir-benchmark-cli/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ cli/                    # Interfaz de usuario
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands.js         # Definici√≥n de comandos CLI
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blessed-ui.js       # Dashboard blessed (v2+)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ simple-cli.js       # CLI b√°sico (MVP)
‚îÇ   ‚îú‚îÄ‚îÄ benchmarks/             # Harness de pruebas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pipeline.js         # Pipeline completo de benchmarking
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stages.js           # Medici√≥n por etapas individuales
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ comparisons.js      # Comparaciones entre backends
‚îÇ   ‚îú‚îÄ‚îÄ profilers/              # Sistema de medici√≥n
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ performance.js      # perf_hooks + m√©tricas tiempo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memory.js           # process.memoryUsage() + tracking
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cpu.js              # CPU profiling + flamegraphs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gc.js               # Garbage collection monitoring
‚îÇ   ‚îú‚îÄ‚îÄ backends/               # Wrappers para sistemas de prueba
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ultra-honk.js       # UltraHonk wrapper + m√©tricas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ultra-plonk.js      # UltraPlonk wrapper + m√©tricas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ base.js             # Backend base class
‚îÇ   ‚îú‚îÄ‚îÄ circuits/               # Gesti√≥n de circuitos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loader.js           # Carga y parseo de circuitos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validator.js        # Validaci√≥n de inputs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ examples/           # Circuitos predefinidos
‚îÇ   ‚îú‚îÄ‚îÄ reporters/              # Exportadores de m√©tricas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv.js              # Exportaci√≥n CSV
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ json.js             # Exportaci√≥n JSON estructurado
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ flamegraph.js       # Generaci√≥n flamegraphs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ console.js          # Pretty printing para terminal
‚îÇ   ‚îî‚îÄ‚îÄ utils/                  # Utilidades y configuraci√≥n
‚îÇ       ‚îú‚îÄ‚îÄ config.js           # Configuraci√≥n global
‚îÇ       ‚îú‚îÄ‚îÄ logger.js           # Sistema de logging
‚îÇ       ‚îî‚îÄ‚îÄ helpers.js          # Funciones auxiliares
‚îú‚îÄ‚îÄ circuits/                   # Circuitos de ejemplo compilados
‚îÇ   ‚îú‚îÄ‚îÄ simple-hash/            # SHA256 simple
‚îÇ   ‚îú‚îÄ‚îÄ merkle-tree/            # Merkle tree verification
‚îÇ   ‚îú‚îÄ‚îÄ signature-verify/       # ECDSA signature verification
‚îÇ   ‚îú‚îÄ‚îÄ recursive-proof/        # Recursive proof verification
‚îÇ   ‚îî‚îÄ‚îÄ large-circuit/          # Circuito grande (>100k constraints)
‚îú‚îÄ‚îÄ config/                     # Configuraciones predefinidas
‚îÇ   ‚îú‚îÄ‚îÄ benchmarks.json         # Configuraciones de benchmark
‚îÇ   ‚îú‚îÄ‚îÄ circuits.json           # Metadata de circuitos
‚îÇ   ‚îî‚îÄ‚îÄ thresholds.json         # Thresholds para alertas
‚îú‚îÄ‚îÄ reports/                    # Salidas de m√©tricas
‚îÇ   ‚îú‚îÄ‚îÄ json/                   # Reportes JSON detallados
‚îÇ   ‚îú‚îÄ‚îÄ csv/                    # Datos CSV para an√°lisis
‚îÇ   ‚îî‚îÄ‚îÄ flamegraphs/            # CPU flamegraphs
‚îú‚îÄ‚îÄ scripts/                    # Scripts auxiliares
‚îÇ   ‚îú‚îÄ‚îÄ setup.js                # Setup inicial del proyecto
‚îÇ   ‚îú‚îÄ‚îÄ compile-circuits.js     # Compilaci√≥n de circuitos
‚îÇ   ‚îî‚îÄ‚îÄ generate-test-data.js   # Generaci√≥n de datos de prueba
‚îî‚îÄ‚îÄ docs/                       # Documentaci√≥n adicional
    ‚îú‚îÄ‚îÄ API.md                  # Documentaci√≥n API
    ‚îú‚îÄ‚îÄ CIRCUITS.md             # Gu√≠a de circuitos
    ‚îî‚îÄ‚îÄ PROFILING.md            # Gu√≠a de profiling
```

---

## üîß APIs y Dependencias

### Dependencias Principales
```json
{
  "dependencies": {
    "@noir-lang/noir_js": "^0.31.0",
    "@noir-lang/acvm_js": "^0.31.0", 
    "@noir-lang/noirc_abi": "^0.31.0",
    "@aztec/bb.js": "latest",
    "commander": "^11.0.0",
    "blessed": "^0.1.81",
    "blessed-contrib": "^4.11.0",
    "csv-writer": "^1.6.0",
    "json2csv": "^6.1.0"
  },
  "devDependencies": {
    "nargo": "^0.31.0",
    "0x": "^5.5.0",
    "clinic": "^13.0.0"
  }
}
```

### APIs Core de NoirJS
```javascript
// Inicializaci√≥n WASM
import initNoirC from "@noir-lang/noirc_abi";
import initACVM from "@noir-lang/acvm_js";
await Promise.all([initACVM(fetch(acvm)), initNoirC(fetch(noirc))]);

// Pipeline b√°sico
import { Noir } from '@noir-lang/noir_js';
import { UltraHonkBackend } from '@aztec/bb.js';

const noir = new Noir(circuit);
const backend = new UltraHonkBackend(circuit.bytecode);
const { witness } = await noir.execute(inputs);
const { proof, publicInputs } = await backend.generateProof(witness);
const verified = await backend.verifyProof({ proof, publicInputs });
```

### APIs de Performance
```javascript
const { performance, PerformanceObserver } = require('perf_hooks');

// Medici√≥n por etapas
performance.mark('acir-decode-start');
// ... operaci√≥n ...
performance.mark('acir-decode-end');
performance.measure('acir-decode', 'acir-decode-start', 'acir-decode-end');

// Monitoreo de memoria
const memBefore = process.memoryUsage();
// ... operaci√≥n ...
const memAfter = process.memoryUsage();
```

---

## üìä Sistema de M√©tricas

### M√©tricas Por Etapa
```typescript
interface StageMetrics {
  stage: 'acir-decode' | 'acvm-execute' | 'backend-init' | 'proof-generate' | 'proof-verify';
  timeMs: number;
  memoryBefore: NodeJS.MemoryUsage;
  memoryAfter: NodeJS.MemoryUsage;
  memoryDelta: {
    heapUsed: number;
    heapTotal: number;
    external: number;
    rss: number;
  };
  cpu?: {
    userTime: number;
    systemTime: number;
  };
}
```

### M√©tricas Globales
```typescript
interface BenchmarkResult {
  circuit: {
    name: string;
    size: number; // n√∫mero de constraints
    bytecodeSize: number;
  };
  backend: 'UltraHonk' | 'UltraPlonk';
  configuration: {
    threads: number;
    isWarm: boolean; // cold vs warm run
  };
  stages: StageMetrics[];
  totals: {
    timeMs: number;
    memoryPeak: number;
    proofSize: number;
    witnessSize: number;
  };
  srs: {
    loadTimeMs: number;
    sizeBytes: number;
    cached: boolean;
  };
  timestamp: string;
  environment: {
    nodeVersion: string;
    platform: string;
    cpuModel: string;
    memoryTotal: number;
  };
}
```

### Thresholds y Alertas
```json
{
  "performance_thresholds": {
    "acir_decode_max_ms": 100,
    "acvm_execute_max_ms": 1000,
    "backend_init_max_ms": 2000,
    "proof_generate_max_ms": 30000,
    "memory_peak_max_mb": 1000,
    "witness_size_max_elements": 100000
  },
  "memory_thresholds": {
    "heap_growth_max_mb": 500,
    "gc_frequency_max_per_minute": 10,
    "external_memory_max_mb": 200
  }
}
```

---

## üß™ Circuitos de Ejemplo

### 1. Simple Hash (MVP)
```noir
// circuits/simple-hash/src/main.nr
use dep::std;

fn main(preimage: [u8; 32]) -> pub [u8; 32] {
    std::hash::sha256(preimage)
}
```
- **Constraints:** ~1,000
- **Prop√≥sito:** Baseline r√°pido para validar pipeline
- **Inputs:** 32 bytes random
- **Tiempo esperado:** <5 segundos

### 2. Merkle Tree Verification
```noir
// circuits/merkle-tree/src/main.nr
use dep::std;

fn main(
    leaf: [u8; 32],
    path: [[u8; 32]; 20],
    indices: [u1; 20],
    root: pub [u8; 32]
) {
    let computed_root = std::merkle::compute_merkle_root(leaf, path, indices);
    assert(computed_root == root);
}
```
- **Constraints:** ~20,000
- **Prop√≥sito:** Circuito de tama√±o medio, operaciones hash intensivas
- **Tiempo esperado:** 10-30 segundos

### 3. ECDSA Signature Verification
```noir
// circuits/signature-verify/src/main.nr
use dep::std;

fn main(
    message: [u8; 32],
    signature: [u8; 64], 
    pub_key: [u8; 64]
) {
    let valid = std::ecdsa_secp256k1::verify_signature(pub_key, signature, message);
    assert(valid);
}
```
- **Constraints:** ~100,000+
- **Prop√≥sito:** Circuito computacionalmente intensivo
- **Tiempo esperado:** 1-5 minutos

### 4. Large Circuit (Stress Test)
```noir
// circuits/large-circuit/src/main.nr
fn main(inputs: [Field; 1000]) -> pub Field {
    let mut result = 0;
    for i in 0..1000 {
        result += inputs[i] * inputs[i];
        result = std::hash::pedersen([result])[0];
    }
    result
}
```
- **Constraints:** ~500,000+
- **Prop√≥sito:** Stress test para memoria y tiempo
- **Tiempo esperado:** 5-15 minutos

---

## üñ•Ô∏è Interfaz de Usuario

### MVP: CLI B√°sico
```bash
# Ejecutar benchmark simple
./noir-benchmark --circuit simple-hash --backend UltraHonk

# Comparar backends
./noir-benchmark --circuit merkle-tree --compare-backends

# Benchmark completo con reporte
./noir-benchmark --all-circuits --threads 4 --output report.json

# Profiling detallado
./noir-benchmark --circuit signature-verify --profile --flamegraph
```

### V2: Dashboard Blessed
```
‚îå‚îÄ NoirJS Benchmark Dashboard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ Current Benchmark ‚îÄ‚îê  ‚îå‚îÄ Progress ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Circuit: merkle-tree ‚îÇ  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë 90% ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Backend: UltraHonk   ‚îÇ  ‚îÇ Stage: Proof Generation            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Threads: 4           ‚îÇ  ‚îÇ ETA: 2.3s                          ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ Live Metrics ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ Memory Usage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Time: 45.2s          ‚îÇ  ‚îÇ     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 512MB      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Memory: 512MB        ‚îÇ  ‚îÇ Heap: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 256MB      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ CPU: 85%             ‚îÇ  ‚îÇ WASM: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 128MB      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ Stage Breakdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ ACIR Decode    [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 0.1s   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ACVM Execute   [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 2.3s   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Backend Init   [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 1.8s   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Proof Gen      [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 42.1s  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìà Roadmap de Desarrollo

### Fase 1: MVP (Semana 1)
- [x] SPECS.md completo
- [ ] CLI b√°sico funcional
- [ ] Un circuito de ejemplo (simple-hash)
- [ ] Pipeline completo ACIR ‚Üí Proof
- [ ] M√©tricas b√°sicas (tiempo + memoria)
- [ ] Output JSON estructurado

### Fase 2: Comparaciones (Semana 2)
- [ ] M√∫ltiples circuitos de ejemplo
- [ ] Comparaci√≥n UltraHonk vs UltraPlonk
- [ ] Configuraciones de threading
- [ ] Cold vs warm run analysis
- [ ] Exportaci√≥n CSV para an√°lisis

### Fase 3: Dashboard Avanzado (Semana 3)
- [ ] Interfaz blessed interactiva
- [ ] Dashboard tiempo real
- [ ] Visualizaci√≥n gr√°fica de m√©tricas
- [ ] Configuraci√≥n persistente

### Fase 4: Profiling Avanzado (Semana 4)
- [ ] CPU flamegraphs autom√°ticos
- [ ] GC monitoring y memory leak detection
- [ ] Browser benchmarking support
- [ ] Integraci√≥n Chrome DevTools

### Fase 5: Optimizaci√≥n (Semana 5+)
- [ ] SRS caching strategies
- [ ] Multi-circuit batching
- [ ] Automated regression testing
- [ ] Performance regression alerts

---

## üß™ Testing y Validaci√≥n

### Test Matrix
```
Circuitos: [simple-hash, merkle-tree, signature-verify, large-circuit]
Backends: [UltraHonk, UltraPlonk]  
Threads: [1, 2, 4, 8]
Runs: [cold, warm]
Environment: [Node.js, Browser]
```

### Criterios de √âxito MVP
- ‚úÖ Pipeline completo funcional
- ‚úÖ M√©tricas precisas por etapa
- ‚úÖ Comparaci√≥n reproducible entre runs
- ‚úÖ Output estructurado para an√°lisis
- ‚úÖ Documentaci√≥n clara de uso

---

## üîç Consideraciones T√©cnicas

### Limitaciones Conocidas
- Barretenberg max circuit size: 2^19 gates (524,288)
- WASM memory limits en browser
- SRS initialization overhead en cold runs
- GC pauses pueden afectar m√©tricas

### Estrategias de Optimizaci√≥n
- Reutilizar instancias de backend cuando sea posible
- Cache SRS entre runs del mismo tama√±o
- Usar Worker threads para profiling no intrusivo
- Batch multiple circuits para throughput tests

### Seguridad y Robustez
- Validar inputs de circuitos antes de ejecuci√≥n
- Timeouts configurables para evitar colgadas
- Graceful degradation si fallan backends
- Logs detallados para debugging

---

## üìö Referencias

- [NoirJS Documentation](https://noir-lang.org/docs/reference/NoirJS/)
- [Barretenberg TypeScript](https://github.com/AztecProtocol/barretenberg/tree/master/ts)
- [ACVM Documentation](https://github.com/noir-lang/acvm-docs)
- [Node.js Performance Hooks](https://nodejs.org/api/perf_hooks.html)
- [Blessed Terminal UI](https://github.com/chjj/blessed)

---

*Este documento ser√° actualizado conforme evolucione la implementaci√≥n.*